/*******************************************************************************
* Copyright (c) 2012 Harman International (http://www.harman.com).
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* 2012-03-06: Klaus Birken (initial version)
* 2017-07-28: Bernhard Hennlich (BMW AG: extension for component model)
*******************************************************************************/
grammar org.franca.compdeploymodel.dsl.FDeploy with org.eclipse.xtext.common.Terminals  

// the fDeploy ecore model (it is not generated from this grammar)
import "http://www.franca.org/compdeploymodel/dsl/FDeploy"

// the Franca IDL ecore model
import "http://core.franca.org" as fidl

// the Franca Component ecore model
import "http://org.franca.compmodel.dsl" as fcomp

// the Ecore ecore model
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// **************************************************************
// model root

FDModel:
	'package' name=FQN
	(imports+=Import)*
	(specifications+=FDSpecification)*
	(deployments+=FDRootElement)*
	;

Import :
	'import' (importURI=STRING|importedSpec=FQN);
	

// **************************************************************
// property definition (meta part)

FDSpecification:
	'specification' name=FQN ('extends' base=[FDSpecification|FQN])? '{'
		(declarations+=FDDeclaration)*
	'}';

FDDeclaration: 
	'for' host=FDPropertyHost '{'
		properties+=FDPropertyDecl*
	'}';

FDPropertyDecl:
	name=ID ':' type=FDTypeRef
		('(' flags+=FDPropertyFlag (',' flags+=FDPropertyFlag)* ')')?
	';' ;

FDPropertyFlag:
	optional='optional' | typed='typed' |
	'default:' default=FDComplexValue;


enum FDPropertyHost:
	providers | instances |
	type_collections | interfaces |
	attributes | methods | broadcasts |
	attribute_setters | attribute_getters | attribute_notifiers |
	arguments |
	struct_fields | union_fields | fields |
	arrays | structs | unions |
	enumerations | enumerators |
	typedefs |
	strings | numbers | integers | floats | booleans | byte_buffers |
	components | services | required_ports | provided_ports |
	devices | variants | adapters;


// **************************************************************
// deployment model type system

FDTypeRef:
	(predefined=FDPredefinedTypeId | complex=FDType) (array='[]')?;

enum FDPredefinedTypeId:
	Integer | String | Boolean | Interface | Instance | Enumerator | Constant ;

FDType:
	FDEnumType;

FDEnumType:
	'{' enumerators+=FDEnumerator (',' enumerators+=FDEnumerator)* '}';

FDEnumerator:
	name=ID;


// **************************************************************
// content definition (model part)

FDRootElement:
	FDProvider | FDTypes | FDInterface |
	FDComponent | FDDevice | FDService | FDVariant |
	FDProvidedPort | FDRequiredPort | FDComAdapter;

FDElement:
	FDRootElement | FDInterfaceInstance | 
	FDAttribute | FDOperation | FDArgument | 
	FDTypeDefinition | FDField | FDEnumeration | FDEnumValue;

FDProvider:
	comment=FDAnnotationBlock?
	'define' spec=[FDSpecification|FQN]
	'for' 'provider' name=FQN
	'{'
		('use' use+=[FDRootElement|FQN])*

		// the own properties of this interface provider
		properties=FDPropertySet
		
		// instances of interfaces
		instances+=FDInterfaceInstance*
	'}';
	
// Additional property hosts for component modeling
FDService:
	comment=FDAnnotationBlock?
	'define' spec=[FDSpecification|FQN]	'for' 'service' target=FDComponentInstance ('as' name=ID)? ('{'
		('use' use+=[FDComponent|FQN])*

		// the own properties of this service
		properties=FDPropertySet
		
		// ports of component
		(providedPorts+=FDProvidedPort|
		requiredPorts+=FDRequiredPort)*
	'}')?;
	
FDDevice:
	comment=FDAnnotationBlock?
	'define' spec=[FDSpecification|FQN]
	'for' 'device' target=[fcomp::FCDevice|FQN] ('as' name = ID)?
	('{'
		('use' use+=[FDService|FQN])*
		
		// the own properties of the device
		properties=FDPropertySet
		
		(adapters+=FDComAdapter)*
	'}')?;
	
FDComponentInstance:
	target=[fcomp::FCComponent]
	({FDComponentInstance.parent=current} '.' prototype=[fcomp::FCGenericPrototype])*;
	

FDComAdapter:
	comment=FDAnnotationBlock? 
	'adapter' target=[fcomp::FCComAdapter] 'on' spec=[FDSpecification|FQN]
	('{'
		('use' use+=[FDProvidedPort|FQN])*
		properties=FDPropertySet
	'}')?
;

FDVariant:
	comment=FDAnnotationBlock?
	'define' 'variant' name=ID 'for' 'root' root=[fcomp::FCComponent]? 
	('{'
		('use' use+=[FDDevice|FQN])*
	'}')?;

	
FDComponent:
	comment=FDAnnotationBlock?
	'define' spec=[FDSpecification|FQN]
	'for' 'component' target=[fcomp::FCComponent|FQN] ('as' name=FQN)?
	'{'
		// the own properties of this component
		properties=FDPropertySet
		
		// ports of component
		(providedPorts+=FDProvidedPort|
		requiredPorts+=FDRequiredPort)*
	'}';
	
FDPort: FDProvidedPort | FDRequiredPort;

FDRequiredPort:
	comment=FDAnnotationBlock?
	'require' target=[fcomp::FCRequiredPort|FQN] ('on' spec=[FDSpecification|FQN])?
	('{' 
		('use' use+=[FDRootElement|FQN])*
		
		// the own properties of this component
		properties=FDPropertySet
	'}')?;

FDProvidedPort:
	comment=FDAnnotationBlock?
	'provide' target=[fcomp::FCProvidedPort|FQN] ('on' spec=[FDSpecification|FQN])?
	('{'
		('use' use+=[FDInterface|FQN])*
		
		// the own properties of this component
		properties=FDPropertySet
	'}')?;
	
// deployment of plain interfaces w/o components
FDInterfaceInstance:
	comment=FDAnnotationBlock?
	'instance' target=[fidl::FInterface|FQN] ('as' name=FQN)? '{'
		properties=FDPropertySet
	'}';

FDTypes:
	comment=FDAnnotationBlock?
	'define' spec=[FDSpecification|FQN]
	'for' 'typeCollection' target=[fidl::FTypeCollection|FQN] ('as' name=FQN)?
	'{'
		('use' use+=[FDRootElement|FQN])*
		
		// the own properties of this typeCollection
		properties=FDPropertySet

		// properties for all type definitions in the package		
		types+=FDTypeDefinition*
	'}';

FDInterface:
	comment=FDAnnotationBlock?
	'define' spec=[FDSpecification|FQN]
	'for' 'interface' target=[fidl::FInterface|FQN]
	('as' name=FQN)?
	'{'
		('use' use+=[FDRootElement|FQN])*

		// the own properties of this interface
		properties=FDPropertySet
		
		// properties for the interface's elements
		(
			attributes+=FDAttribute |		
			methods+=FDMethod |
			broadcasts+=FDBroadcast |
			types+=FDTypeDefinition
		)*
	'}';

FDAttribute:
	comment=FDAnnotationBlock?
	'attribute' target=[fidl::FAttribute|FQN] '{'
		properties=FDPropertySet
		(overwrites=FDTypeOverwrites)?
	'}';
	
FDOperation:
	FDMethod | FDBroadcast;

FDMethod:
	comment=FDAnnotationBlock?
	'method' target=[fidl::FMethod|FQN_WITH_SELECTOR] '{'
		properties=FDPropertySet
		('in' inArguments=FDArgumentList)?
		('out' outArguments=FDArgumentList)?
	'}';

FDBroadcast:
	comment=FDAnnotationBlock?
	'broadcast' target=[fidl::FBroadcast|FQN_WITH_SELECTOR] '{'
		properties=FDPropertySet
		('out' outArguments=FDArgumentList)?
	'}';
	
FDArgumentList:
	{FDArgumentList}
	'{' arguments+=FDArgument* '}';

FDArgument:
	comment=FDAnnotationBlock?
	target=[fidl::FArgument|FQN] '{'
		properties=FDPropertySet
		(overwrites=FDTypeOverwrites)?
	'}';

FDTypeDefinition: FDArray | FDCompound | FDEnumeration | FDTypedef;
FDCompound: FDStruct | FDUnion;

FDArray:
	comment=FDAnnotationBlock?
	'array' target=[fidl::FArrayType|FQN] '{'
		properties=FDPropertySet
		(overwrites=FDTypeOverwrites)?
	'}';
	
FDStruct:
	comment=FDAnnotationBlock?
	'struct' target=[fidl::FStructType|FQN] '{'
		properties=FDPropertySet
		fields+=FDField*
	'}';

FDUnion:
	comment=FDAnnotationBlock?
	'union' target=[fidl::FUnionType|FQN] '{'
		properties=FDPropertySet
		fields+=FDField*
	'}';

FDTypedef:
	comment=FDAnnotationBlock?
	'typedef' target=[fidl::FTypeDef|FQN] '{'
		properties=FDPropertySet
	'}';
	
FDField:
	comment=FDAnnotationBlock?
	target=[fidl::FField|FQN] '{'
		properties=FDPropertySet
		(overwrites=FDTypeOverwrites)?
	'}';

FDEnumeration:
	comment=FDAnnotationBlock?
	'enumeration' target=[fidl::FEnumerationType|FQN] '{'
		properties=FDPropertySet
		enumerators+=FDEnumValue*
	'}';

FDEnumValue:
	comment=FDAnnotationBlock?
	target=[fidl::FEnumerator|FQN] '{'
		properties=FDPropertySet
	'}';

FDTypeOverwrites:
	'#'            FDPlainTypeOverwrites |
	'#struct'      FDStructOverwrites |
	'#union'       FDUnionOverwrites |
	'#enumeration' FDEnumerationOverwrites;

FDPlainTypeOverwrites:
	{FDPlainTypeOverwrites}
	comment=FDAnnotationBlock?
	'{'
		properties=FDPropertySet // the actually overwritten properties
	'}';

FDStructOverwrites:
	comment=FDAnnotationBlock?
	'{'
		properties=FDPropertySet // the actually overwritten properties
		(fields+=FDField)*
	'}';

FDUnionOverwrites:
	comment=FDAnnotationBlock?
	'{'
		properties=FDPropertySet // the actually overwritten properties
		(fields+=FDField)*
	'}';

FDEnumerationOverwrites:
	{FDEnumerationOverwrites}
	comment=FDAnnotationBlock?
	'{'
		properties=FDPropertySet // the actually overwritten properties
		(enumerators+=FDEnumValue)*
	'}';


// **************************************************************
// property definition 

FDPropertySet:
	{FDPropertySet}
	(items+=FDProperty ((',')? items+=FDProperty)*)?;

FDProperty:
	decl=[FDPropertyDecl|ID] '=' value=FDComplexValue;

FDComplexValue:
	single=FDValue | array=FDValueArray;

FDValueArray:
	'{' values+=FDValue (',' values+=FDValue)* '}';

// a typed constant value 
FDValue:
	FDInteger | FDString | FDBoolean | FDInterfaceRef | FDGeneric | FDEnumeratorRef | FDConstantDefRef;
	
FDInteger:	    	value=SignedInt;
FDString:	    	value=STRING;
FDBoolean:      	value=('false'|'true');
FDInterfaceRef: 	'&' value=[fidl::FInterface|FQN];
FDEnumeratorRef:	'enumerator' value=[fidl::FEnumerator|FQN];
FDConstantDefRef:	'const' value=[fidl::FConstantDef|FQN];

// FDGeneric.value might be one of:
//   - [FDEnumerator|ID]
//   - [FDInterfaceInstance|FQN]
// See FDModelUtils for some helper functions.
FDGeneric:      value=[ecore::EObject|FQN];


// **************************************************************
// general

FQN:
	ID ('.' ID)*;

// this is used for referencing overloaded FMethod and FBroadcast
FQN_WITH_SELECTOR:
	FQN (':' ID)?;

// positive or negative integer
SignedInt returns ecore::EInt:
	NEGATIVE_INT | INT | HEX | BINARY;

// terminal rule: negative integer
terminal NEGATIVE_INT returns ecore::EInt:
	'-' ('0'..'9')+;

// terminal rule: hexadecimal literal
terminal HEX:
	 ('0x'|'0X')(('0'..'9')|('a'..'f')|('A'..'F'))+;

// terminal rule: binary literal
terminal BINARY:
	 ('0b'|'0B')('0'|'1')+;

// **************************************************************
// annotations
terminal ANNOTATION_STRING returns ecore::EString:
	'@' (('a'..'z')|'-')+ (' '|'\t')* ':'
	( ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\')) | ('\\*'|'\\@') | !('\\'|'*'|'@') )*
;

FDAnnotationBlock:
	'<**' (elements+=FDAnnotation)+ '**>';

FDAnnotation:
	rawText=ANNOTATION_STRING;
